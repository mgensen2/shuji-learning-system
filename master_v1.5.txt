#include <esp_now.h>
#include <WiFi.h>

/*
コマンド解説
コマンド基本の並び
(再生モード) (引数1) (引数2) (引数3) ...
※コマンドと引数の間は半角スペースで区切ること

再生モード種別
・A1 (スピーカ番号) (再生時間ms) (ボリューム)
  指定したスピーカでホワイトノイズを再生し、指定時間後に停止信号を送る

・A2 (スピーカ番号) (再生時間ms) (ボリューム) [中心周波数Hz] [周波数幅Hz] [音量調整]
  指定したスピーカでバンドパスノイズを再生し、指定時間後に停止信号を送る
  ※フィルタ設定[...]は省略可能。省略した場合はCコマンドの設定値が使われる

・A3 (スピーカ番号)
  指定したスピーカに停止信号を送る

・B1 (スピーカ番号) (再生時間ms) (ボリューム)
  指定したスピーカでホワイトノイズを再生する（停止信号は送らない）

・B2 (スピーカ番号) (再生時間ms) (ボリューム) [中心周波数Hz] [周波数幅Hz] [音量調整]
  指定したスピーカでバンドパスノイズを再生する（停止信号は送らない）
  ※フィルタ設定[...]は省略可能。省略した場合はCコマンドの設定値が使われる

・C (中心周波数Hz) (周波数幅Hz) (音量調整)
  バンドパスノイズ(A2, B2)のデフォルトフィルタ設定を変更する
  ※音量調整: 0=そのまま, 1=下げる, 2=上げる

・D1 (待機時間ms)
  指定した時間だけプログラムを待機させる

・P (プリセット番号)
  あらかじめ定義されたコマンドシーケンスを実行する
*/

//=================================================================
// ▼▼▼ プリセット定義セクション ▼▼▼
//=================================================================

// プリセット1: スピーカ1番から8番までを順番に鳴らす
const char* preset1[] = {
  "A1 1 150 120",
  "A1 2 150 120",
  "A1 3 150 120",
  "A1 4 150 120",
  // A2コマンドで直接フィルタを指定
  "A2 5 150 120 2000 800 0",
  "A2 6 150 120 1000 400 2",
  "A2 7 150 120", // このコマンドはCコマンドのデフォルト値で再生される
  "A2 8 150 120"
};

// プリセット2: バンドパスフィルタを設定し、異なる2つのスピーカを鳴らす
const char* preset2[] = {
  "C 2000 800 0",
  "A2 10 500 110",
  "A2 20 500 110"
};

// プリセット3: 複数のスピーカを同時に鳴らして止める（Bコマンドを利用）
const char* preset3[] = {
  "B1 1 10 120",   // 4つのスピーカに再生コマンドを連続送信
  "B1 8 10 120",
  "B1 57 10 120",
  "B1 64 10 120",
  "D1 1000",       // 1秒待機
  "A3 1",          // 4つのスピーカに停止コマンドを送信
  "A3 8",
  "A3 57",
  "A3 64"
};


// --- システム用定義 (通常は編集不要) ---
const char** presets[] = { preset1, preset2, preset3 };
const int preset_sizes[] = {
  sizeof(preset1) / sizeof(preset1[0]),
  sizeof(preset2) / sizeof(preset2[0]),
  sizeof(preset3) / sizeof(preset3[0])
};
const int NUM_PRESETS = sizeof(presets) / sizeof(presets[0]);
//=================================================================
// ▲▲▲ プリセット定義セクションはここまで ▲▲▲
//=================================================================


// ESP-NOWのピア情報（ブロードキャスト用）
esp_now_peer_info_t slave;

// バンドパスモードのデフォルト設定値を保持するグローバル変数（Cコマンドで変更）
uint16_t bandpassCenterFreq = 1000; // 中心周波数 (Hz)
uint16_t bandpassWidth = 500;       // 周波数幅 (Hz)
uint8_t bandpassVolAdjust = 0;      // 音量微調整 (0:そのまま, 1:下げる, 2:上げる)

// --- 各種関数定義 ---

// データ送信完了時のコールバック関数
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print("Last Packet Sent to: ");
  Serial.println(macStr);
  Serial.print("Last Packet Send Status: ");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

// 送信するdata配列の内容をシリアルモニタに表示する関数
void printDataForDebug(const char* title, const uint8_t* data, size_t size) {
  Serial.print("--- DEBUG: Sending ");
  Serial.print(title);
  Serial.println(" ---");
  Serial.print("Data Bytes (HEX): ");
  for (size_t i = 0; i < size; i++) {
    if (data[i] < 0x10) {
      Serial.print("0");
    }
    Serial.print(data[i], HEX);
    Serial.print(" ");
  }
  Serial.println("\n---------------------------------");
}

// スピーカ番号(1-64)から、スレーブユニット用の位置情報に変換する関数
void getSpeakerLocation(int speakerId, int &redFrame, bool &isBlueFrame, int &speakerInFrame) {
  if (speakerId < 1 || speakerId > 64) {
    redFrame = -1;
    return;
  }
  int row = (speakerId - 1) / 8 + 1;
  int col = (speakerId - 1) % 8 + 1;
  redFrame = (col - 1) / 2 + 1;
  isBlueFrame = (row > 4);
  int localRow = isBlueFrame ? (row - 4) : row;
  speakerInFrame = (localRow - 1) * 2 + (col % 2 == 0 ? 2 : 1);
}

// --- コマンド処理関数 ---

// ホワイトノイズ再生コマンド (A1) の処理
void handleA1Command(int speakerId, int duration, int volume) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame;
  data[1] = 8;
  data[2] = volume;
  data[3] = 8;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; }
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  for (int i = 6; i < 12; i++) { data[i] = 0; }

  printDataForDebug("A1 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);

  data[1] = 17;
  data[3] = 17;
  printDataForDebug("A1 Stop Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

// バンドパスモード再生コマンド (A2) の処理
void handleA2Command(int speakerId, int duration, int volume, uint16_t centerFreq, uint16_t width, uint8_t volAdjust) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame;
  data[1] = 14;
  data[2] = 0;
  data[3] = 14;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; }
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  data[6] = (centerFreq >> 8) & 0xFF;
  data[7] = centerFreq & 0xFF;
  data[8] = (width >> 8) & 0xFF;
  data[9] = width & 0xFF;
  data[10] = volAdjust;
  data[11] = volume;

  printDataForDebug("A2 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);

  data[1] = 17;
  data[3] = 17;
  printDataForDebug("A2 Stop Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

// 停止コマンド (A3) の処理
void handleA3Command(int speakerId) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame;
  data[1] = 17;
  data[2] = 0;
  data[3] = 17;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; }
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  for (int i = 6; i < 12; i++) { data[i] = 0; }
  
  printDataForDebug("A3 Stop Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

// ホワイトノイズ再生コマンド (B1) の処理 (停止なし)
void handleB1Command(int speakerId, int duration, int volume) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame;
  data[1] = 8;
  data[2] = volume;
  data[3] = 8;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; }
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  for (int i = 6; i < 12; i++) { data[i] = 0; }

  printDataForDebug("B1 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);
}

// バンドパスモード再生コマンド (B2) の処理 (停止なし)
void handleB2Command(int speakerId, int duration, int volume, uint16_t centerFreq, uint16_t width, uint8_t volAdjust) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame;
  data[1] = 14;
  data[2] = 0;
  data[3] = 14;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; }
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  data[6] = (centerFreq >> 8) & 0xFF;
  data[7] = centerFreq & 0xFF;
  data[8] = (width >> 8) & 0xFF;
  data[9] = width & 0xFF;
  data[10] = volAdjust;
  data[11] = volume;

  printDataForDebug("B2 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);
}

// コンフィグモードコマンド (C) の処理
void handleCCommand(int centerFreq, int width, int volAdjust) {
  bandpassCenterFreq = centerFreq;
  bandpassWidth = width;
  bandpassVolAdjust = volAdjust;

  Serial.println("--- Default Bandpass Filter Config Updated ---");
  Serial.printf("Center Frequency: %d Hz\n", bandpassCenterFreq);
  Serial.printf("Bandwidth: %d Hz\n", bandpassWidth);
  Serial.print("Volume Adjust: ");
  if(volAdjust == 0) Serial.println("Keep");
  else if(volAdjust == 1) Serial.println("Down");
  else if(volAdjust == 2) Serial.println("Up");
  Serial.println("--------------------------------------------");
}

// 待機コマンド (D1) の処理
void handleD1Command(int duration) {
  Serial.printf("Executing D1: Delaying for %dms\n", duration);
  delay(duration);
}

// プリセット実行コマンド (P) の処理
void handlePCommand(int presetNum);
void executeCommand(String command);

void handlePCommand(int presetNum) {
  int presetIndex = presetNum - 1;
  if (presetIndex < 0 || presetIndex >= NUM_PRESETS) {
    Serial.println("Error: Preset number out of range.");
    return;
  }
  Serial.printf("\n--- Executing Preset %d ---\n", presetNum);
  for (int i = 0; i < preset_sizes[presetIndex]; i++) {
    String command_str = presets[presetIndex][i];
    executeCommand(command_str);
  }
  Serial.printf("--- Preset %d Finished ---\n\n", presetNum);
}

// --- コマンドパーサーとメインロジック ---

// 文字列コマンドを解釈して適切な処理関数を呼び出す
void executeCommand(String command) {
  command.trim();
  if (command.length() == 0) return;

  char mode[3];
  int p1 = 0, p2 = 0, p3 = 0, p4 = 0, p5 = 0, p6 = 0;
  // 最大7引数まで読み取れるように変更
  int num_args = sscanf(command.c_str(), "%s %d %d %d %d %d %d", mode, &p1, &p2, &p3, &p4, &p5, &p6);

  if (num_args >= 1) {
    if (String(mode) == "A1" && num_args == 4) {
      Serial.printf("Executing A1: Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
      handleA1Command(p1, p2, p3);
    } 
    else if (String(mode) == "A2") {
      if (num_args == 4) { // 引数が4つの場合、デフォルトのフィルタ設定を使用
        Serial.printf("Executing A2 (default filter): Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
        handleA2Command(p1, p2, p3, bandpassCenterFreq, bandpassWidth, bandpassVolAdjust);
      } else if (num_args == 7) { // 引数が7つの場合、指定されたフィルタ設定を使用
        Serial.printf("Executing A2 (custom filter): Speaker=%d, Duration=%dms, Volume=%d, Freq=%d, Width=%d, Adj=%d\n", p1, p2, p3, p4, p5, p6);
        handleA2Command(p1, p2, p3, p4, p5, p6);
      } else {
        Serial.println("Invalid A2 command: Wrong number of arguments.");
      }
    }
    else if (String(mode) == "A3" && num_args == 2) {
      Serial.printf("Executing A3: Stop Speaker=%d\n", p1);
      handleA3Command(p1);
    } 
    else if (String(mode) == "B1" && num_args == 4) {
      Serial.printf("Executing B1: Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
      handleB1Command(p1, p2, p3);
    } 
    else if (String(mode) == "B2") {
      if (num_args == 4) { // 引数が4つの場合、デフォルトのフィルタ設定を使用
        Serial.printf("Executing B2 (default filter): Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
        handleB2Command(p1, p2, p3, bandpassCenterFreq, bandpassWidth, bandpassVolAdjust);
      } else if (num_args == 7) { // 引数が7つの場合、指定されたフィルタ設定を使用
        Serial.printf("Executing B2 (custom filter): Speaker=%d, Duration=%dms, Volume=%d, Freq=%d, Width=%d, Adj=%d\n", p1, p2, p3, p4, p5, p6);
        handleB2Command(p1, p2, p3, p4, p5, p6);
      } else {
        Serial.println("Invalid B2 command: Wrong number of arguments.");
      }
    }
    else if (String(mode) == "C" && num_args == 4) {
      Serial.printf("Executing C: CenterFreq=%d, Width=%d, VolAdjust=%d\n", p1, p2, p3);
      handleCCommand(p1, p2, p3);
    } 
    else if (String(mode) == "D1" && num_args == 2) {
      handleD1Command(p1);
    } 
    else if (String(mode) == "P" && num_args == 2) {
      handlePCommand(p1);
    } 
    else {
      Serial.print("Invalid command or wrong number of arguments: ");
      Serial.println(command);
    }
  }
}

void setup() {
  Serial.begin(115200);

  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESPNow Init Failed");
    ESP.restart();
  }

  memset(&slave, 0, sizeof(slave));
  for (int i = 0; i < 6; ++i) { slave.peer_addr[i] = (uint8_t)0xff; }
  if (esp_now_add_peer(&slave) != ESP_OK) {
    Serial.println("Pair failed");
  }
  esp_now_register_send_cb(OnDataSent);
  delay(1000);

  Serial.println("\nSetup Complete. Enter command.");
  Serial.println("Play White Noise (Auto Stop): A1 (ID) (Time_ms) (Vol)");
  Serial.println("  ex) A1 32 500 120");
  Serial.println("Play Bandpass (Auto Stop):    A2 (ID) (Time_ms) (Vol) [Freq] [Width] [Adjust]");
  Serial.println("  ex) A2 1 1000 100");
  Serial.println("  ex) A2 1 1000 100 2000 500 1");
  Serial.println("Play White Noise (No Stop):   B1 (ID) (Time_ms) (Vol)");
  Serial.println("  ex) B1 32 500 120");
  Serial.println("Play Bandpass (No Stop):      B2 (ID) (Time_ms) (Vol) [Freq] [Width] [Adjust]");
  Serial.println("  ex) B2 1 1000 100");
  Serial.println("  ex) B2 1 1000 100 800 300 2");
  Serial.println("Stop Sound Early:             A3 (ID)");
  Serial.println("  ex) A3 32");
  Serial.println("Configure Default Filter:     C (Freq) (Width) (Adjust)");
  Serial.println("  ex) C 1500 500 0");
  Serial.println("Delay:                        D1 (Time_ms)");
  Serial.println("  ex) D1 1000");
  Serial.println("Execute Preset:               P (Preset#)");
  Serial.println("  ex) P 1");
}

void loop() {
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    executeCommand(command);
  }
}