#include <esp_now.h>
#include <WiFi.h>
/*
コマンド解説
コマンド基本の並び
(再生モード) (スピーカ番号) (再生時間) (ボリューム)
※数字と数字の間は半角スペースで区切ること
再生モード種別
ホワイトノイズ→A1
バンドパスモード→A2
コンフィグモードコマンド(バンドパス数値設定)
C (中心周波数) (周波数の幅) (音量調整)
※どちらも単位はhz
音量調整は 0そのまま　1下げる 2上げる
*/
//[cite start] =================================================================
//[cite start] ▼▼▼ プリセット定義セクション ▼▼▼
//[cite start] ここで実行したいコマンドの組み合わせを自由に追加・編集できます。
//[cite start] =================================================================

//[cite start] プリセット1: スピーカ1番から8番までを順番に短く鳴らす
const char* preset1[] = {
  "A1 1 150 120",
  "A1 2 150 120",
  "A1 3 150 120",
  "A1 4 150 120",
  "C 2000 800 0",
  "A2 5 150 120",
  "C 1000 400 2",
  "A2 6 150 120",
  "A2 7 150 120",
  "A2 8 150 120"
};

//[cite start] プリセット2: バンドパスフィルタを設定し、異なる2つのスピーカを鳴らす
const char* preset2[] = {
  "C 2000 800 0",
  "A2 10 500 110",
  "A2 20 500 110"
};

//[cite start] プリセット3: 複数のスピーカを同時に鳴らして止める（スレーブ側の性能によります）
const char* preset3[] = {
  "A1 1 1000 120",
  "A1 8 1000 120",
  "A1 57 1000 120",
  "A1 64 1000 120"
};


//[cite start] --- システム用定義 (通常は編集不要) ---
//[cite start] 作成したプリセットをここに登録します
const char** presets[] = { preset1, preset2, preset3 };
//[cite start] 各プリセットのコマンド数を自動計算します
const int preset_sizes[] = { 
  sizeof(preset1) / sizeof(preset1[0]), 
  sizeof(preset2) / sizeof(preset2[0]),
  sizeof(preset3) / sizeof(preset3[0])
};
const int NUM_PRESETS = sizeof(presets) / sizeof(presets[0]);
//[cite start] =================================================================
//[cite start] ▲▲▲ プリセット定義セクションはここまで ▲▲▲
//[cite start] =================================================================


//[cite start] ESP-NOWのピア情報（ブロードキャスト用）
esp_now_peer_info_t slave;

//[cite start] バンドパスモード（A2コマンド）で使用する設定値を保持するグローバル変数
uint16_t bandpassCenterFreq = 1000; //[cite start]
uint16_t bandpassWidth = 500;       //[cite start]
uint8_t bandpassVolAdjust = 0;      //[cite start]

//[cite start] --- 各種関数定義 ---

//[cite start] データ送信完了時のコールバック関数
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print("Last Packet Sent to: ");
  Serial.println(macStr);
  Serial.print("Last Packet Send Status: ");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

//[cite start] 送信するdata配列の内容をシリアルモニタに表示する関数
void printDataForDebug(const char* title, const uint8_t* data, size_t size) {
  Serial.print("--- DEBUG: Sending ");
  Serial.print(title);
  Serial.println(" ---");
  Serial.print("Data Bytes (HEX): ");
  for (size_t i = 0; i < size; i++) {
    if (data[i] < 0x10) {
      Serial.print("0"); //[cite start]
    }
    Serial.print(data[i], HEX);
    Serial.print(" ");
  }
  Serial.println("\n---------------------------------");
}

//[cite start] スピーカ番号(1-64)から、スレーブユニット用の位置情報に変換する関数
void getSpeakerLocation(int speakerId, int &redFrame, bool &isBlueFrame, int &speakerInFrame) {
  if (speakerId < 1 || speakerId > 64) {
    redFrame = -1; //[cite start]
    return;
  }
  int row = (speakerId - 1) / 8 + 1;
  int col = (speakerId - 1) % 8 + 1;
  redFrame = (col - 1) / 2 + 1;
  isBlueFrame = (row > 4);
  int localRow = isBlueFrame ? (row - 4) : row;
  speakerInFrame = (localRow - 1) * 2 + (col % 2 == 0 ? 2 : 1);
}

//[cite start] --- コマンド処理関数 ---

//[cite start] ホワイトノイズ再生コマンド (A1) の処理
void handleA1Command(int speakerId, int duration, int volume) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame; 
  data[1] = 8; 
  data[2] = volume; 
  data[3] = 8; 
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; } 
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  for (int i = 6; i < 12; i++) { data[i] = 0; }

  printDataForDebug("A1 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);

  data[1] = 17;
  data[3] = 17;
  printDataForDebug("A1 Stop Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

//[cite start] バンドパスモード再生コマンド (A2) の処理
void handleA2Command(int speakerId, int duration, int volume) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }

  uint8_t data[12];
  data[0] = redFrame; 
  data[1] = 14; 
  data[2] = 0; 
  data[3] = 14; 
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; } 
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  data[6] = (bandpassCenterFreq >> 8) & 0xFF; 
  data[7] = bandpassCenterFreq & 0xFF; 
  data[8] = (bandpassWidth >> 8) & 0xFF; 
  data[9] = bandpassWidth & 0xFF; 
  data[10] = bandpassVolAdjust; 
  data[11] = volume; 

  printDataForDebug("A2 Play Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(duration);

  data[1] = 17;
  data[3] = 17;
  printDataForDebug("A2 Stop Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

//[cite start] 停止コマンド (A3) の処理
void handleA3Command(int speakerId) {
  int redFrame;
  bool isBlueFrame;
  int speakerInFrame;
  getSpeakerLocation(speakerId, redFrame, isBlueFrame, speakerInFrame);
  if (redFrame == -1) { return; }
  
  uint8_t data[12];
  data[0] = redFrame;
  if (isBlueFrame) { data[4] = 1 << (speakerInFrame - 1); data[5] = 0; } 
  else { data[4] = 0; data[5] = 1 << (speakerInFrame - 1); }
  data[1] = 17;
  data[3] = 17;
  data[2] = 0;
  for (int i = 6; i < 12; i++) { data[i] = 0; }

  printDataForDebug("A3 Packet", data, sizeof(data));
  esp_now_send(slave.peer_addr, data, sizeof(data));
  delay(10);
}

//[cite start] コンフィグモードコマンド (C) の処理
void handleCCommand(int centerFreq, int width, int volAdjust) {
  bandpassCenterFreq = centerFreq; 
  bandpassWidth = width; 
  bandpassVolAdjust = volAdjust; 
  Serial.println("--- Bandpass Filter Config Updated ---");
  Serial.printf("Center Frequency: %d Hz\n", bandpassCenterFreq);
  Serial.printf("Bandwidth: %d Hz\n", bandpassWidth);
  Serial.printf("Volume Adjust: %d\n", bandpassVolAdjust);
  Serial.println("------------------------------------");
}

//[cite start] プリセット実行コマンド (P) の処理
void handlePCommand(int presetNum);
void executeCommand(String command);

void handlePCommand(int presetNum) {
  int presetIndex = presetNum - 1; //[cite start] ユーザーは1から、配列は0から始まるため調整
  if (presetIndex < 0 || presetIndex >= NUM_PRESETS) {
    Serial.println("Error: Preset number out of range.");
    return;
  }

  Serial.printf("\n--- Executing Preset %d ---\n", presetNum);
  for (int i = 0; i < preset_sizes[presetIndex]; i++) {
    String command_str = presets[presetIndex][i];
    executeCommand(command_str);
  }
  Serial.printf("--- Preset %d Finished ---\n\n", presetNum);
}

//[cite start] --- コマンドパーサーとメインロジック ---

//[cite start] 文字列コマンドを解釈して適切な処理関数を呼び出す
void executeCommand(String command) {
  command.trim();
  if (command.length() == 0) return;

  char mode[3];
  int p1 = 0, p2 = 0, p3 = 0;
  int num_args = sscanf(command.c_str(), "%s %d %d %d", mode, &p1, &p2, &p3);

  if (num_args >= 1) {
    if (String(mode) == "A1" && num_args == 4) { 
      Serial.printf("Executing A1: Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
      handleA1Command(p1, p2, p3);
    } else if (String(mode) == "A2" && num_args == 4) { 
      Serial.printf("Executing A2: Speaker=%d, Duration=%dms, Volume=%d\n", p1, p2, p3);
      handleA2Command(p1, p2, p3);
    } else if (String(mode) == "A3" && num_args == 2) {
      Serial.printf("Executing A3: Stop Speaker=%d\n", p1);
      handleA3Command(p1);
    } else if (String(mode) == "C" && num_args == 4) { 
      Serial.printf("Executing C: CenterFreq=%d, Width=%d, VolAdjust=%d\n", p1, p2, p3);
      handleCCommand(p1, p2, p3);
    } else if (String(mode) == "P" && num_args == 2) {
      handlePCommand(p1);
    } else {
      Serial.print("Invalid command: ");
      Serial.println(command);
    }
  }
}

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESPNow Init Failed");
    ESP.restart();
  }
  memset(&slave, 0, sizeof(slave));
  for (int i = 0; i < 6; ++i) { slave.peer_addr[i] = (uint8_t)0xff; }
  if (esp_now_add_peer(&slave) != ESP_OK) {
    Serial.println("Pair failed");
  }
  esp_now_register_send_cb(OnDataSent);
  delay(1000);

  Serial.println("\nSetup Complete. Enter command.");
  Serial.println("Play White Noise: A1 (SpeakerID) (Time_ms) (Volume)");
  Serial.println("   ex) A1 32 500 120");
  Serial.println("Play Bandpass:    A2 (SpeakerID) (Time_ms) (Volume)");
  Serial.println("   ex) A2 1 1000 100");
  Serial.println("Stop Sound Early: A3 (SpeakerID)");
  Serial.println("   ex) A3 32");
  Serial.println("Configure Filter: C (CenterFreq) (Width) (VolAdjust)");
  Serial.println("   ex) C 1500 500 0");
  Serial.println("Execute Preset:   P (Preset#)");
  Serial.println("   ex) P 1");
}

void loop() {
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    executeCommand(command);
  }
}