/*
 * あたま
 * speakerarrayのマスタプログラム
 * このプログラムでspeakerarrayを制御
 */

/*
 * 使用する音源データヘッダファイル
 * flashが許す限り追加可能
 *ヘッダーファイルごとに音源読み込む？
 */
#include "beep.h"
#include <esp_now.h>//esp_nowのライブラリ
#include <WiFi.h>//wifiのライブラリ
#include "driver/twai.h"//can(twai)のライブラリ

/*
 * 音源データの構造体
 */
typedef struct {
  uint8_t wavData;         // ヘッダファイルの1バイトをコピーする変数
  uint8_t sendByte[8];     // 8バイトを格納しておく変数
  uint64_t count;          // 読み込む箇所の変数
} WAV;

esp_now_peer_info_t slave;

/*
 * WAV型の宣言
 */
WAV wav = {0, 0, 0};

uint8_t msg[12];
uint8_t flag = 0;


/**
// 受信コールバック
void OnDataRecv(const uint8_t *mac_addr, const uint8_t *data, int data_len) {
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.printf("Last Packet Recv from: %s\n", macStr);
  Serial.printf("Last Packet Recv Data(%d): ", data_len);
  Serial.println("");
  for ( int i = 0 ; i < data_len ; i++ ) {
    msg[i] = data[i];
    //Serial.println(msg[i]);
  }
  //Serial.println("");
  flag = 1; //フラグを立てる
}
**/

/*
 * 受信コールバック（新形式）エラーはいたらうえを有効にし, こちらをコメントアウト
 */
void OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *data, int data_len) {
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           recv_info->src_addr[0], recv_info->src_addr[1], recv_info->src_addr[2],
           recv_info->src_addr[3], recv_info->src_addr[4], recv_info->src_addr[5]);

  Serial.printf("Last Packet Recv from: %s\n", macStr);
  Serial.printf("Last Packet Recv Data(%d): ", data_len);
  Serial.println("");

  for (int i = 0; i < data_len; i++) {
    msg[i] = data[i];
  }
  flag = 1;
}

/*
 * マイコンと周辺モジュールのsetup
 */
void setup() {
  Serial.begin(115200);
  while (!Serial);

  WiFi.mode(WIFI_STA);
  WiFi.disconnect();

  if (esp_now_init() == ESP_OK) {
    Serial.println("ESPNow Init Success");
  } else {
    Serial.println("ESPNow Init Failed");
    ESP.restart();
  }

  // マルチキャスト用Slave登録
  memset(&slave, 0, sizeof(slave));
  for (int i = 0; i < 6; ++i) {
    slave.peer_addr[i] = (uint8_t)0xff;
  }

  esp_err_t addStatus = esp_now_add_peer(&slave);
  if (addStatus == ESP_OK) {
    Serial.println("Pair success");
  }

  // ESP-NOWコールバック登録
  esp_now_register_recv_cb(OnDataRecv);

  // TWAIドライバ設定
  twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(GPIO_NUM_27, GPIO_NUM_26, TWAI_MODE_NORMAL);
  twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();
  twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

  if (twai_driver_install(&g_config, &t_config, &f_config) == ESP_OK) {
    printf("Driver installed\n");
  } else {
    printf("Failed to install driver\n");
    return;
  }

  if (twai_start() == ESP_OK) {
    printf("Driver started\n");
  } else {
    printf("Failed to start driver\n");
    return;
  }

  Serial.println("let's speakerarray");
}

/*
 * マイコンのloop関数
 */
void loop() {
  if (flag == 1) {
    JudgeMode(msg);
  }
}

/*
 * 入力分岐処理関数
 */
void JudgeMode(uint8_t *inputNumber) {
  uint32_t address = 0;

  if ((msg[0] == 3) || (msg[0] == 5)) { //msgの番号でセンター番号識別
    switch (inputNumber[1]) {
      case 1://wav音源用のファイル再生コマンド
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
         uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          PlaySound(address);
          Serial.println("Play Sound");
          break;
        }
        flag = 0;
        break;

      case 2://wav音源用の停止コマンド
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          StopSound(address);
          Serial.println("stop Sound");
          break;
        }
        flag = 0;
        break;

      case 3://wav転送データ命令
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println("Sending sound");
        /*最大８個まで音源を選べる*/
          // サウンドデータの送信
          if(msg[2] == 0b00000001){
            //SendWavData(hitsuon, sizeof(hitsuon), address);
          }else if(msg[2] == 0b00000010){
            SendWavData(beep, sizeof(beep), address);
          }else if(msg[2] == 0b00000100){
            //SendWavData(sin800, sizeof(sin800), address);
          }else if(msg[2] == 0b00001000){
            //SendWavData(sin1000, sizeof(sin1000), address);
          }else if(msg[2] == 0b00010000){
            //SendWavData(sin1200, sizeof(sin1200), address);
          }else if(msg[2] == 0b00100000){
            //SendWavData(sin1400, sizeof(sin1400), address);
          }

          Serial.println("Send sound");
          break;
        }
        flag = 0;
        break;
      case 8://ホワイトノイズ再生命令
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          int8_t vol = msg[2];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          Whitenoise(address,vol);
          break;
        }
        flag = 0;
        break;
      case 13://i2c再開関数
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          i2c_buffer(address);
          break;
        }
        flag = 0;
        break;
      case 14://バンドパス再生命令
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          int8_t band1 = msg[6];
          int8_t band2 = msg[7];
          int8_t band3 = msg[8];
          int8_t band4 = msg[9];
          int8_t band5 = msg[10];
          int8_t band6 = msg[11];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          Bandpass(address,band1,band2,band3,band4,band5,band6);
          break;
        }
        flag = 0;
        break;
      case 17://ホワイトノイズとバンドパス用の停止命令
        while (1) {
          int8_t temp = msg[3];
          int8_t temp2 = msg[4];
          int8_t temp3 = msg[5];
          uint16_t addres_val = makeWord(temp2, temp3);
          address = Uint16ToUint32(temp, addres_val);
          Serial.println(address);
          StopSound(address);
          break;
        }
        flag = 0;
        break;
      default:
        Serial.println("1 : 再生, 2 : 停止, 3 : 音源選択");
        flag = 0;
        break;
    }
  }
}

/*
 * wavファイル用のスピーカから再生する関数
 */
void PlaySound(uint32_t address) {
  twai_message_t message = {
    .extd = 1, //拡張フォーマット基本的に1            
    .rtr = 0, //データ送信フレーム             
    .ss = 0, //再送モード               
    .self = 0,              
    .dlc_non_comp = 0,
    .identifier = address, //上位16ビット:スレーブのisMyCommandで行う処処理, 下位16ビット:アドレス
    .data_length_code = 1,
    .data = {0},
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}

/*
 * wavファイル用の再生停止関数
 */
void StopSound(uint32_t address) {
  twai_message_t message = {
    .extd = 1,
    .rtr = 0,
    .ss = 0,
    .self = 0,
    .dlc_non_comp = 0,
    .identifier = address,
    .data_length_code = 1,
    .data = {0},
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}

/*
 * 音源データ送信関数
 */
void SendWavData(const unsigned char *audio, uint32_t length, uint32_t address) {
  Serial.println("go sound");
  while (wav.count < length) {
    for (int i = 0; i < 8; ++i) {
      memcpy(&wav.wavData, (char*)audio + wav.count, sizeof(wav.wavData));
      wav.sendByte[i] = wav.wavData;
      wav.count += 1;
    }
  Serial.println("send ok");
    twai_message_t message = {
      .extd = 1,
      .rtr = 0,
      .ss = 0,
      .self = 0,
      .dlc_non_comp = 0,
      .identifier = address,
      .data_length_code = 8,
      .data = {
        wav.sendByte[0], wav.sendByte[1], wav.sendByte[2], wav.sendByte[3],
        wav.sendByte[4], wav.sendByte[5], wav.sendByte[6], wav.sendByte[7]
      },
    };

    if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
      printf("Message queued for transmission\n");
    } else {
      printf("Failed to queue message for transmission\n");
    }
  }

  twai_message_t message = {
    .extd = 1,
    .rtr = 0,
    .ss = 0,
    .self = 0,
    .dlc_non_comp = 0,
    .identifier = 0b1001111111111111111,
    .data_length_code = 1,
    .data = {0},
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}
//ホワイトノイズ関数
void Whitenoise(uint32_t address,uint8_t vol) {
  Serial.println("noisepiyo\n");//デバック
  Serial.println(vol);//.dataの中身確認
  twai_message_t message = {
    .extd = 1,
    .rtr = 0,
    .ss = 0,
    .self = 0,
    .dlc_non_comp = 0,
    .identifier = address,
    /*ここまでおまじない*/
    .data_length_code = 1,//データの長さ
    .data = {vol},//送信データ格納
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}
//バンドパス関数
void Bandpass(uint32_t address,uint8_t band1,uint8_t band2,uint8_t band3,uint8_t band4,uint8_t band5,uint8_t band6) {
  Serial.println("bandpiyo\n");//デバック
  Serial.println(band1);//.dataの中身確認
  Serial.println(band2);//.dataの中身確認
  Serial.println(band3);//.dataの中身確認
  Serial.println(band4);//.dataの中身確認
  Serial.println(band5);//.dataの中身確認
  Serial.println(band6);//.dataの中身確認
  twai_message_t message = {
    .extd = 1,
    .rtr = 0,
    .ss = 0,
    .self = 0,
    .dlc_non_comp = 0,
    .identifier = address,
    .data_length_code = 6,
    .data = {band1,band2,band3,band4,band5,band6},
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}
//i2c再開関数
void i2c_buffer(uint32_t address) {
  Serial.println("i2cpiyo\n");//デバック
  twai_message_t message = {
    .extd = 1,
    .rtr = 0,
    .ss = 0,
    .self = 0,
    .dlc_non_comp = 0,
    .identifier = address,
    /*ここまでおまじない*/
    .data_length_code = 0,//データの長さ
    .data = {},//送信データ格納
  };

  if (twai_transmit(&message, pdMS_TO_TICKS(1000)) == ESP_OK) {
    printf("Message queued for transmission\n");
  } else {
    printf("Failed to queue message for transmission\n");
  }
}
/*
 * ASCIIコード→10進数変換関数
 */
uint8_t AsciiToDec(uint8_t ascii) {
  return ascii - '0';
}

/*
 * 16bit→32bit変換関数
 */
uint32_t Uint16ToUint32( uint8_t high_val,uint16_t low_val) {
  uint32_t result = (high_val << 16) | low_val;
  return result;
}

/* おしり */
